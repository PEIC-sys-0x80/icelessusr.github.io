# C 語言基本語法
#程式設計 #程式語言基礎結構 #C語言

C 是一種強型別、靜態編譯、支持過程式設計的程式語言。以下為 C 在不引入任何函式庫（包括標準函式庫）的情況下的所有通用語法與程式結構。
## 1. 程式結構

- C 語言程式由 **函式（Function）** 構成，必須有一個 `main()` 函式作為入口點。
- **指令（Statements）** 以分號（`;`）結尾。

```c
int main() {
    return 0;
}
```

### 各種開發環境的 `main()` 替代函式

在不同的 C 語言開發環境中，`main()` 可能會被不同的函式取代，例如：

| 開發環境                     | 入口函式                                          |
| ------------------------ | --------------------------------------------- |
| 標準 C/C++                 | `int main()`                                  |
| Arduino                  | `setup()` & `loop()`                          |
| Windows Driver Kit (WDK) | `DriverEntry()`                               |
| Linux Kernel             | `init_module()` / `module_init()`             |
| UEFI 開發                  | `efi_main()`                                  |
| FreeRTOS                 | `vTaskStartScheduler()` (通常使用 `main()` 來啟動任務) |
| ESP-IDF (ESP32)          | `app_main()`                                  |
| Bootloader               | `start()` 或 `Reset_Handler()`                 |


### 返回和回傳
- `int`：返回型別，表示返回一個整數。
- `return 0;`：回傳狀態碼，0 代表正常結束。



## 2. 資料型別（Data Types）

- `char`（字元）
- `int`（整數）
- `float`（單精度浮點數）
- `double`（雙精度浮點數）

此外，C 語言提供了修飾符來改變變數的儲存範圍和精度：

- `signed`：允許存儲正負數。
- `unsigned`：僅存儲非負數，範圍加倍。
- `short`：減少儲存空間（通常 2 個位元組）。
- `long`：增加儲存空間（通常 4 或 8 個位元組）。

```c
int a = 10;
char c = 'A';
float f = 3.14;
double d = 3.141592

  signed int a = -10;     // 允許存儲正負數
  unsigned int b = 300;   // 只能存儲非負數，範圍加倍
  short int c = 32767;    // 通常 2 個位元組
  long int d = 2147483647; // 通常 4 或 8 個位元組
  long long int e = 9223372036854775807LL; // 更大的範圍，通常 8 個位元組
```



### 2.5布林值(需要使用`stdbool.h`)
- `bool`（布林值，需包含 `<stdbool.h>`）

bool 並不是 C 語言的內建基本型別，而是由 `<stdbool.h>` 提供的類型。

```c
#include <stdbool.h>

bool flag = true;
```

在標準 C（C89、C90）中，C 語言沒有 `bool`，只能用 `int` 來表示布林值（例如 `0` 表示 `false`，非 `0` 表示 `true`）。

到了 C99，`<stdbool.h>` 被引入，定義了 `bool` 為 `typedef`，讓程式碼更易讀，但它本質上仍然是 `int`。

如果不包含 `<stdbool.h>`，你仍然可以用以下方式模擬布林型別：

```c
typedef enum { false, true } bool;
```
這樣就能在不依賴標頭檔的情況下使用 bool。

如果你的程式需要支援更舊的 C 標準（如 C90），那麼使用 int 來表示布林值會更兼容。

## 3. 變數與常數

- 變數需先宣告才能使用。
- 常數使用 `const` 或 `#define` 定義。

```c
int x = 5;
const double PI = 3.14159;
#define MAX 100
```

## 4. 運算子（Operators）
### **算術運算子 (Arithmetic Operators)**  
- `+`：相加  
- `-`：相減  
- `*`：相乘  
- `/`：相除  
- `%`：取餘數 (取模)  

### **比較運算子 (Relational Operators)**  
- `==`：等於 (判斷兩值是否相等)  
- `!=`：不等於 (判斷兩值是否不相等)  
- `>`：大於  
- `<`：小於  
- `>=`：大於或等於  
- `<=`：小於或等於  

### **邏輯運算子 (Logical Operators)**  
- `&&`：邏輯 AND (當兩個條件都為真時結果為真)  
- `||`：邏輯 OR (當至少一個條件為真時結果為真)  
- `!`：邏輯 NOT (反轉布林值)  

### **位元運算子 (Bitwise Operators)**  
- `&`：按位 AND (對應位元都為 1 結果才為 1)  
- `|`：按位 OR (對應位元只要有 1 結果就為 1)  
- `^`：按位 XOR (對應位元不同時結果為 1，相同為 0)  
- `~`：按位 NOT (對所有位元取反)  
- `<<`：左移運算 (位元向左移動，低位補 0，相當於乘以 2 的 n 次方)  
- `>>`：右移運算 (位元向右移動，高位補 0 或 1，視數值類型而定，相當於除以 2 的 n 次方)  

### **賦值運算子 (Assignment Operators)**  
- `=`：賦值 (將右側值賦給左側變數)  
- `+=`：加後賦值 (等價於 `a = a + b`)  
- `-=`：減後賦值 (等價於 `a = a - b`)  
- `*=`：乘後賦值 (等價於 `a = a * b`)  
- `/=`：除後賦值 (等價於 `a = a / b`)  
- `%=`：取模後賦值 (等價於 `a = a % b`)  

### **條件運算子 (Ternary Operator)**  
- `?:`：三元運算子 (`條件 ? 表達式1 : 表達式2`，若條件為真則返回表達式1，否則返回表達式2)  

```c
int a = 10, b = 5;
int sum = a + b;
int isEqual = (a == b) ? 1 : 0;
```

## 5. 控制流程（Control Flow）

### 條件判斷（if、else、switch）
- 使用`if`和`else`建立判斷結構
- `switch`建立選擇結構；`break`跳出`case`

```c
// if else 範例
int x = 10;
if (x > 5) {
    // x 大於 5
} else {
    // x 小於或等於 5
}

// switch 範例
int y = 3;
switch (y) {
    case 1:
        // y 等於 1
        break; //跳出case，如果沒跳出則會繼續往下執行其他case
    case 3:
        // y 等於 3
        break;
    default:
        // 其他情況
        break;
}

```

### 迴圈（while、do-while、for）
- `while`: 建立一個條件迴圈，當符合條件時執行內容
- `do`+`while`: 和上述相同，但在第一次執行時，無論是否符合條件都會先執行一次指令
- `for` :確定執行次數的迴圈

```c
// while 範例
int i = 0;
while (i < 5) {
    // i 從 0 到 4 逐次執行
    i++;
}

// do-while 範例
int j = 0;
do {
    // j 從 0 開始執行一次，然後檢查條件
    j++;
} while (j < 3);

// for 範例
for (int k = 0; k < 3; k++) {
    // k 從 0 到 2 逐次執行
}

```

### 跳轉語句（break、continue、goto）
- `togo`:跳轉到指定位置
- `break`: 強制結束目前迴圈或選擇結構的循環
- `continue`: 類似`break`，但不會結束循環，而是跳過當前循環，強制開啟下一輪循環。

```c
// break 範例
for (int i = 0; i < 5; i++) {
    if (i == 3) {
        break;  // 當 i 等於 3 時，退出迴圈
    }
}

// continue 範例
for (int i = 0; i < 5; i++) {
    if (i == 2) {
        continue;  // 當 i 等於 2 時，跳過此次迴圈，繼續下一次
    }
    // 其他 i 不等於 2 時執行
}

// goto 範例
int count = 0;
start:
if (count < 3) {
    // 執行某些操作
    count++;
    goto start;  // 重複回到 start 標籤
}

```

## 6. 陣列與指標

### 陣列
陣列可以是各種資料型態，可以視為一個可以儲存多個數的變數。
```c
int arr[5] = {1, 2, 3, 4, 5}; //整數陣列
char yeeee[4] = {"豬","雞","牛","羊"}; //字串陣列
float yek[3] = {6.1,7.3,8.1};//單精度浮點數陣列
double yee[3] = {1.4317664938,2.1562333,3.141592653589}; //雙倍精度浮點數陣列
```

### 指標
- **指標存放記憶體位址**，可透過 `&` 取得變數位址，`*` 來存取該位址的值。
- **指標運算** 可讓我們輕鬆遍歷陣列 (`ptr++`) 或操作記憶體。
- **指標與陣列** 密切相關，陣列名稱即指向首元素的指標。
- **指標是 C 語言強大的特性**，但使用時需謹慎避免指標錯誤。

#### **1. 指標的基本概念**

指標 (Pointer) 是**一種變數，其值是一個記憶體位址**。換句話說，指標**存儲的是某個變數或物件的位址，而不是具體的數值**。

在 C 語言中，指標主要用於：
- **存取記憶體位址**
- **間接操作變數的值**
- **陣列與指標運算**
- **動態記憶體管理**
- **函數指標 (callback function)**

---

#### **2. 指標的語法與功能**
**(1) 指標的宣告與初始化**
```c
int *ptr;  // 宣告一個指向 int 型態的指標
```
這表示 `ptr` 變數**存放的是某個 int 型變數的記憶體位址**，而不是 int 型的值。

若要讓 `ptr` 指向某個變數，可以使用「位址運算子 (`&`)」：
```c
int num = 10;
ptr = &num;  // 將 num 的記憶體位址存入 ptr
```
此時，`ptr` 指向 `num`，我們可以透過**解參照運算子 (`*`)** 來取得 `ptr` 指向的變數值：
```c
printf("%d\n", *ptr);  // 輸出 10
```

---

**(2) 指標運算**
指標可以進行數學運算，最常見的是「指標加減 (`+` 或 `-`)」，這與陣列存取密切相關：
```c
int arr[] = {10, 20, 30};
int *ptr = arr;  // 等同於 int *ptr = &arr[0];

ptr++;  // 指向下一個元素 (arr[1])
```
指標的加減運算會根據其型態自動偏移。例如，`ptr++` 會將指標往後移動 `sizeof(int)`（通常是 4 bytes）。

---

**(3) 指標與陣列**
指標與陣列有緊密的關係，因為陣列的名稱 (`arr`) **本身就代表該陣列的起始位址**：
```c
int arr[] = {10, 20, 30};
int *ptr = arr;  // 等價於 ptr = &arr[0]
```
這讓我們可以用指標來遍歷陣列：
```c
for (int i = 0; i < 3; i++) {
    printf("%d ", *(ptr + i));  // 依序輸出 10 20 30
}
```

---

#### **3. 指標的應用**
指標在 C 語言中用途廣泛，主要用於：
1. **陣列與字串處理**（用指標遍歷陣列或字串）
2. **動態記憶體管理**（透過 `malloc()`、`free()` 等函數）
3. **函數指標**（用於回調函數）
4. **資料結構**（如鏈結串列、樹等）
5. **指標與結構體**（在系統開發中非常重要）

---

#### **4. 注意事項**
1. **避免野指標 (Dangling Pointer)**  
   - 指標變數在使用前**必須初始化**，否則它可能指向不明位置，導致程式崩潰。
   
2. **指標運算需在有效範圍內**  
   - 超出陣列範圍 (`ptr++` 超過 `arr` 限制) 可能導致未定義行為 (undefined behavior)。

3. **釋放動態記憶體**  
   - 若使用 `malloc()` 分配記憶體，務必使用 `free()` 釋放，以避免記憶體洩漏 (Memory Leak)。



### 函式指標


- **函式指標存放函式的記憶體位址**，可以用來呼叫函式。
- **語法為 `return_type (*指標變數名)(參數類型);`**，如 `int (*funcPtr)(int, int);`。
- **函式指標可作為變數，讓程式執行時決定要呼叫哪個函式**。
- **函式指標可用於函式指標陣列、回呼函式 (callback function)、動態函式調用等場景**。

#### **1. 函式指標的基本概念**  
函式指標 (Function Pointer) 是一種**存放函式位址的指標**，它允許我們**透過指標呼叫函式**，這使得程式在執行時可以**選擇不同的函式來執行**。  

在 C 語言中，函式的名稱本身就代表該函式的起始位址，因此**函式指標可以存放這個位址，並透過指標來調用該函式**。

---

#### **2. 函式指標的語法與功能**  

##### **(1) 函式指標的宣告**  
函式指標的宣告語法如下：  
```c
返回值類型 (*指標名稱)(參數類型);
```
例如：
```c
int (*funcPtr)(int, int);
```
這表示 `funcPtr` 是**一個指向回傳 `int` 並接受兩個 `int` 參數的函式指標**。

##### **(2) 函式指標的初始化**
函式指標可以指向符合相同函式型態的函式：
```c
int add(int a, int b) {
    return a + b;
}

int (*funcPtr)(int, int);  // 宣告函式指標
funcPtr = add;  // 讓指標指向函式
```
也可以直接這樣宣告：
```c
int (*funcPtr)(int, int) = add;
```

##### **(3) 透過函式指標呼叫函式**
當函式指標指向了一個函式後，可以透過指標來執行該函式：
```c
int result = funcPtr(3, 4);  // 等同於 add(3, 4)
```
也可以加上 `*`，但這不是必要的：
```c
int result = (*funcPtr)(3, 4);
```
這與 `funcPtr(3, 4);` 效果相同。

---

#### **3. 函式指標的應用**  

##### **(1) 使用函式指標來選擇不同的函式**
函式指標可以根據條件來選擇不同的函式：
```c
int add(int a, int b) { return a + b; }
int multiply(int a, int b) { return a * b; }

int main() {
    int (*operation)(int, int);  // 宣告函式指標
    int x = 5, y = 3;
    
    // 根據條件決定函式指標指向哪個函式
    if (x > y) {
        operation = add;
    } else {
        operation = multiply;
    }

    int result = operation(x, y);  // 呼叫對應的函式
    return 0;
}
```
這樣，`operation` 變數的函式指標可以在執行時決定要執行 `add()` 或 `multiply()`。

---

##### **(2) 使用函式指標陣列**
函式指標也可以存放在陣列中，根據索引值來選擇不同的函式：
```c
int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }

int main() {
    int (*operations[3])(int, int) = {add, subtract, multiply};

    int index = 2;  // 0:加法, 1:減法, 2:乘法
    int result = operations[index](4, 2);  // 相當於 multiply(4, 2)
    return 0;
}
```
這樣可以根據索引來選擇要執行的函式，而不需要 `if-else` 或 `switch`。

---

##### **(3) 變數函式指標 (動態函式調用)**
函式指標可以根據變數的值來決定執行哪個函式：
```c
int hello() { return 1; }
int goodbye() { return 2; }

int main() {
    int (*funcPtr)();  // 宣告一個不帶參數、回傳 int 的函式指標

    int condition = 1;
    if (condition) {
        funcPtr = hello;
    } else {
        funcPtr = goodbye;
    }

    int result = funcPtr();  // 執行對應的函式
    return 0;
}
```
這種方式可以讓程式在執行時動態選擇不同的函式來執行。

---

#### **4. 注意事項**
1. **函式指標的型態必須匹配**
   - 若函式的參數或回傳值類型不匹配，可能導致未定義行為 (Undefined Behavior)。
   
2. **函式名稱就是函式的位址**
   - `funcPtr = add;` 和 `funcPtr = &add;` 作用相同，因為函式名稱本身就是函式的位址。

3. **函式指標不可指向變數**
   - 指標通常指向變數，但函式指標**只能指向函式**。




## 7. 結構體與共用體

- **結構 (`struct`)**：可以存放多個不同類型的變數，每個成員各有獨立的記憶體空間。
- **共用體 (`union`)**：所有成員共享同一塊記憶體，同一時間只能存放一個值，適合節省記憶體的應用場景。
- **結構適合組織多種屬性數據，而共用體適合存放可變數據類型的單一值**。
- **結構與共用體可以搭配使用**，提高記憶體利用率與程式彈性。

#### **1. 結構 (`struct`) 的基本概念**  
結構 (`struct`) 是**一種用來存放多個不同類型變數的自定義資料型態**。它允許我們將不同類型的數據組合成一個單位，使得資料管理更有組織性。

##### **(1) 結構的定義與初始化**
結構的定義語法如下：
```c
struct 結構名稱 {
    資料型態 成員1;
    資料型態 成員2;
    ...
};
```
範例如下：
```c
struct Point {
    int x, y;  // 定義兩個成員變數
};
```
這表示 `Point` 結構內部包含兩個 `int` 型態的變數 `x` 和 `y`，我們可以這樣宣告一個結構變數：
```c
struct Point p1;
p1.x = 5;
p1.y = 10;
```
也可以在宣告時直接初始化：
```c
struct Point p2 = {3, 7};
```

##### **(2) 使用結構指標**
結構變數也可以透過指標來存取：
```c
struct Point p = {1, 2};
struct Point *ptr = &p;

// 透過指標存取結構成員
ptr->x = 4;
ptr->y = 8;
```
`ptr->x` 等價於 `(*ptr).x`，這是因為 `->` 運算子用於存取指標指向的結構成員。

##### **(3) 結構陣列**
結構可以組成陣列：
```c
struct Point points[3] = {{1, 2}, {3, 4}, {5, 6}};
```
存取方式與一般陣列相同：
```c
points[1].x = 10;
```

---

#### **2. 共用體 (`union`) 的基本概念**  
共用體 (`union`) 與結構 (`struct`) 類似，但有一個重要的不同點：  
**共用體的所有成員共享同一塊記憶體，因此同一時間只能存放其中一個成員的值**。  

##### **(1) 共用體的定義與初始化**
共用體的語法如下：
```c
union 共用體名稱 {
    資料型態 成員1;
    資料型態 成員2;
    ...
};
```
範例如下：
```c
union Data {
    int i;
    float f;
};
```
這表示 `Data` 內部可以存放 `int` 或 `float`，但**一次只能存放其中一個值**。例如：
```c
union Data d;
d.i = 10;  // 現在 d 存放的是整數 10
```
若稍後改變 `d.f`：
```c
d.f = 3.14;  // 現在 d 存放的是浮點數 3.14
```
此時 `d.i` 的值會**被覆蓋且變成未定義數據**，因為 `i` 和 `f` 共用相同的記憶體。

##### **(2) 共用體的記憶體特性**
共用體的大小等於其**最大成員的大小**，例如：
```c
union Data {
    int i;   // 4 bytes
    float f; // 4 bytes
    char c;  // 1 byte
};
```
這個 `union Data` 變數的大小為 `4` bytes（取決於 `int` 和 `float` 最大的 `4` bytes）。

---

#### **3. 結構與共用體的比較**  

|  | 結構 (`struct`) | 共用體 (`union`) |
|---|---|---|
| **成員存放方式** | 每個成員都有獨立的記憶體空間 | 所有成員共用同一塊記憶體 |
| **記憶體大小** | **總大小 = 各成員大小的總和** | **大小 = 最大成員的大小** |
| **可同時存取多個成員** | 是的，每個成員互不影響 | 否，每次只能存放一個成員的值 |
| **適用場景** | 需要存放多個獨立的資料 | 需要節省記憶體，只使用其中一種數據類型 |

---

#### **4. 結構與共用體的應用**  

##### **(1) 結構用於組織資料**
結構適合用來表示具有多個屬性的物件，例如：
```c
struct Student {
    int id;
    int age;
};
```
我們可以定義學生資料：
```c
struct Student s1 = {1001, 20};
```

##### **(2) 共用體用於節省記憶體**
共用體適合用來**存放不同類型但不會同時使用的數據**：
```c
union Value {
    int i;
    float f;
};
```
可以用來在某些場景下節省記憶體，例如：
```c
union Value v;
v.i = 42;   // 使用 int
v.f = 3.14; // 現在使用 float，i 的值已經無效
```

##### **(3) 結構與共用體的組合**
結構與共用體可以組合使用，例如：
```c
struct Variable {
    int type;  // 0 表示 int，1 表示 float
    union {
        int i;
        float f;
    } data;
};
```
這樣我們可以根據 `type` 來決定存放 `int` 或 `float`：
```c
struct Variable var;
var.type = 0;
var.data.i = 10;  // 儲存整數
```
如果 `type` 改變：
```c
var.type = 1;
var.data.f = 3.14;  // 儲存浮點數
```
這種設計**有效節省記憶體**，並且讓變數的類型具有彈性。


這些特性讓 C 語言在系統層級的開發（如嵌入式系統、驅動程式）中更有效率地管理記憶體與數據。

## 8. 枚舉（enum）

- **枚舉 (`enum`)** 用於定義一組具名的整數常數，使程式碼更具可讀性與可維護性。
- **枚舉變數其實是整數**，但應使用定義的常數名稱來存取，而非直接使用數字。
- **可以手動指定枚舉值**，未指定的會自動遞增。
- **適用於狀態管理、條件判斷 (`switch`)、類型安全的常數定義**。

#### **1. 枚舉 (`enum`) 的基本概念**  
枚舉 (`enum`) 是**一種用來定義具名整數常數的類型**。它可以讓程式碼更加可讀，並且**限制變數只能使用預先定義的值**。  

在底層，枚舉的每個標識符實際上都是**對應的一個整數值**，預設情況下從 `0` 開始依序遞增，但也可以手動指定數值。

---

#### **2. 枚舉的語法與功能**  

##### **(1) 枚舉的定義與使用**
枚舉的定義語法如下：
```c
enum 枚舉名稱 {
    常數1,
    常數2,
    ...
};
```
範例如下：
```c
enum Color {
    RED,   // 0
    GREEN, // 1
    BLUE   // 2
};
```
這表示 `RED`、`GREEN`、`BLUE` 分別對應數值 `0`、`1`、`2`，我們可以這樣宣告一個枚舉變數：
```c
enum Color c;
c = RED;
```
或者在宣告時直接初始化：
```c
enum Color c = GREEN; // c 會被賦值為 1
```

##### **(2) 手動指定枚舉的值**
枚舉的值可以手動指定：
```c
enum Status {
    SUCCESS = 1,
    FAILURE = -1,
    PENDING = 0
};
```
這樣 `SUCCESS` 為 `1`，`FAILURE` 為 `-1`，`PENDING` 為 `0`。

如果只指定部分值，後續的值會在上一個值的基礎上遞增：
```c
enum Size {
    SMALL = 3,
    MEDIUM,  // 4
    LARGE    // 5
};
```
這表示 `SMALL = 3`，`MEDIUM = 4`，`LARGE = 5`。

##### **(3) 枚舉變數的使用**
因為枚舉實際上是整數，所以可以直接比較：
```c
if (c == RED) {
    // c 為 RED 時執行
}
```
但**不能直接將整數賦值給枚舉變數**，否則可能產生未定義行為：
```c
enum Color c;
// c = 2;  // 雖然 2 代表 BLUE，但這種賦值方式不建議
```

##### **(4) 使用 `typedef` 定義枚舉類型**
可以使用 `typedef` 讓枚舉名稱更簡潔：
```c
typedef enum {
    LOW,
    MEDIUM,
    HIGH
} Level;
```
這樣就可以直接使用 `Level` 宣告變數：
```c
Level lvl = HIGH;
```

---

#### **3. 枚舉的應用**  

##### **(1) 代替 `#define` 定義常數**
在沒有 `enum` 的情況下，可能會使用 `#define` 來定義常數：
```c
#define RED 0
#define GREEN 1
#define BLUE 2
```
但這樣的寫法沒有類型檢查，容易造成錯誤。而使用 `enum`，可以讓編譯器進行類型檢查，避免無效的數值賦值：
```c
enum Color c;
c = 5;  // 可能導致未定義行為，編譯器可能會警告
```

##### **(2) 作為 `switch` 條件**
枚舉常用於 `switch` 語句，提高可讀性：
```c
enum Direction {
    UP, DOWN, LEFT, RIGHT
};

void move(enum Direction d) {
    switch (d) {
        case UP:    // 0
            // 執行向上移動
            break;
        case DOWN:  // 1
            // 執行向下移動
            break;
        case LEFT:  // 2
            // 執行向左移動
            break;
        case RIGHT: // 3
            // 執行向右移動
            break;
    }
}
```
這樣比直接使用數字更容易理解程式碼的意圖。

##### **(3) 用於狀態管理**
枚舉常用來表示狀態，例如：
```c
enum State {
    IDLE,
    RUNNING,
    STOPPED
};

enum State currentState = IDLE;
```
這樣可以清楚表示程式當前的狀態，而不需要使用不直觀的數字。

##### **(4) 使用 `enum` 配合 `struct`**
可以在 `struct` 中使用 `enum` 來表示類別：
```c
struct Task {
    int id;
    enum Status {
        PENDING,
        IN_PROGRESS,
        COMPLETED
    } status;
};
```
這樣 `status` 屬性只能是 `PENDING`、`IN_PROGRESS` 或 `COMPLETED`，提高類型安全性。

---

#### **4. 注意事項**
1. **枚舉實際上是整數，但不建議直接用整數賦值**，應該使用枚舉定義的常數。
2. **枚舉變數的大小取決於編譯器**，但通常是 `int`。
3. **枚舉值可以相同**，但這樣可能降低可讀性：
   ```c
   enum Example {
       A = 1,
       B = 1  // 允許，但不推薦
   };
   ```
4. **避免使用未定義的枚舉值**，否則可能導致程式行為不可預測。

---

枚舉讓程式碼更加直觀，並且可以有效避免魔法數字 (`magic numbers`)，提高程式的可維護性。
## 9. 函式（Functions）

- **函式是程式碼的模組化單位，可接受參數並回傳值。**
- **函式可以有回傳值 (`int`、`float` 等)，或是 `void`（無回傳值）。**
- **函式參數預設是值傳遞，如需修改外部變數需使用指標。**
- **支援遞迴，適用於階乘、費式數列等問題。**
- **使用函式指標可以動態選擇執行的函式。**
- **全域變數可被所有函式存取，但過度使用會影響可讀性。**

#### **1. 函式的基本概念**  
函式 (`function`) 是一個封裝好的程式區塊，它可以**接收輸入（參數）、執行特定的運算，並回傳結果**。函式的使用讓程式碼更具模組化，提高可讀性與重複使用性。

C 語言的函式通常包含以下幾個部分：
1. **回傳類型**（函式的輸出類型）
2. **函式名稱**（識別函式的名稱）
3. **參數列表**（輸入值）
4. **函式主體**（執行的程式碼）

函式的語法如下：
```c
回傳類型 函式名稱(參數列表) {
    // 函式主體
    return 值; // (若有回傳值)
}
```

---

#### **2. 函式的定義與使用**  

##### **(1) 有回傳值的函式**
```c
int add(int a, int b) {
    return a + b;
}
```
這個函式：
- **回傳 `int` 型態的值**（因為 `add` 的回傳類型是 `int`）
- **接受兩個 `int` 型態的參數 `a` 和 `b`**
- **回傳 `a + b` 的結果**

使用方式：
```c
int result = add(3, 4); // result = 7
```

##### **(2) 無回傳值 (`void`) 的函式**
有些函式不需要回傳任何值，此時使用 `void`：
```c
void printHello() {
    // 這個函式沒有回傳值
}
```
使用方式：
```c
printHello(); // 呼叫函式，但不會有回傳值
```

##### **(3) 無參數的函式**
函式也可以不接收參數，例如：
```c
int getNumber() {
    return 42;
}
```
使用方式：
```c
int num = getNumber(); // num = 42
```

##### **(4) 多個參數的函式**
函式可以接收多個參數：
```c
int multiply(int x, int y) {
    return x * y;
}
```
使用方式：
```c
int product = multiply(5, 6); // product = 30
```

---

#### **3. 函式的應用與特性**  

##### **(1) 參數傳遞方式**
C 語言的函式參數**預設是值傳遞**，也就是函式內部的變數是傳遞進來的值的拷貝，對參數的修改不會影響原變數。例如：
```c
void changeValue(int x) {
    x = 10; // 只改變函式內部的變數，外部不受影響
}

int main() {
    int a = 5;
    changeValue(a);
    // a 仍然是 5，不受函式影響
}
```

若要讓函式影響外部變數，需要使用**指標傳遞**：
```c
void changeValue(int *x) {
    *x = 10; // 改變的是指標指向的記憶體位置
}

int main() {
    int a = 5;
    changeValue(&a);
    // a 現在變成 10
}
```

##### **(2) 遞迴函式**
函式可以呼叫自己，這稱為**遞迴**（Recursion）：
```c
int factorial(int n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}
```
這個函式計算 `n!`（階乘），例如：
```c
int result = factorial(5); // result = 120
```

##### **(3) 函式的前向宣告（函式原型 `prototype`）**
在 C 語言中，如果函式的定義寫在 `main()` 之後，則必須**先宣告函式**：
```c
int add(int, int);  // 這是函式原型 (forward declaration)

int main() {
    int sum = add(2, 3);
}

int add(int a, int b) { // 這是函式定義
    return a + b;
}
```
這樣可以讓編譯器提前知道函式的存在，避免錯誤。

##### **(4) 函式指標**
函式也是一種資料類型，可以透過函式指標來動態選擇要執行的函式：
```c
int add(int a, int b) { return a + b; }
int (*funcPtr)(int, int) = add;
```
呼叫方式：
```c
int result = funcPtr(3, 4); // result = 7
```

---

#### **4. 函式與變數作用域**  

##### **(1) 區域變數 (`local variable`)**
函式內部宣告的變數**只能在該函式內使用**：
```c
void example() {
    int x = 5;  // x 是區域變數，只能在 example() 內使用
}
```

##### **(2) 全域變數 (`global variable`)**
在函式外部宣告的變數可供所有函式使用：
```c
int globalVar = 10;

void printGlobal() {
    // 可存取 globalVar
}
```
但**不建議過度使用全域變數**，以免影響程式的可讀性與可維護性。

##### **(3) `static` 變數**
`static` 變數在函式內部宣告時，不會在每次呼叫函式時重新初始化，而是會**保持上次函式執行後的值**：
```c
void counter() {
    static int count = 0; // 只初始化一次
    count++;
}
```

---

### **5. 函式的優點**
- **代碼模組化**：可以將程式拆解為多個獨立的部分，提高可讀性。
- **重複使用**：相同的程式碼可以在不同地方被多次呼叫，避免冗餘。
- **降低錯誤**：如果函式內部有錯誤，只需修改函式，而不需要修改每個使用該函式的地方。
- **提高可維護性**：函式讓程式碼的結構更清晰，便於日後修改與擴展。

---
函式是 C 語言中最基本且最重要的概念之一，它能夠讓程式碼更加結構化，提高可維護性，是寫出高效能 C 程式的關鍵！

## 10. `typedef` 與 `#define`

- **`typedef` 用於定義型別別名，不能用來定義常數。**
- **`#define` 是預處理指令，可用來定義常數與巨集函式，但沒有型別檢查。**
- **`typedef` 適用於型別簡化與結構化，`#define` 適用於數值常數與條件編譯。**
- **`#define` 可替換程式碼片段，但要注意括號使用，以防止優先順序錯誤。**
- **`typedef` 能提升型別安全性，讓程式碼更易讀、可移植。**

---

### **1. `typedef`（型別別名）**  

#### **(1) `typedef` 的基本概念**  
`typedef` 用於**為現有的資料型別創建別名**，讓程式碼更簡潔、可讀性更高，並提升可移植性。

---

#### **(2) `typedef` 的語法**
```c
typedef 現有型別 新名稱;
```
例如：
```c
typedef unsigned long ulong;
```
這樣 `ulong` 就成為 `unsigned long` 的別名，可以這樣使用：
```c
ulong x = 1000000; // 等價於 unsigned long x = 1000000;
```

---

#### **(3) `typedef` 的應用**
##### **(a) 簡化複雜的型別**
如果某個型別名稱過長，`typedef` 可以簡化它：
```c
typedef unsigned long long ull;
ull bigNumber = 1234567890;
```

##### **(b) 簡化結構體 (`struct`) 宣告**
在 C 語言中，結構體 (`struct`) 必須使用 `struct` 關鍵字：
```c
struct Point {
    int x, y;
};
struct Point p1;  // 必須加上 struct
```
但用 `typedef` 可以省略 `struct`：
```c
typedef struct {
    int x, y;
} Point;

Point p1;  // 直接使用 Point，而不用寫 struct
```

##### **(c) 提高可移植性**
如果某個程式需要在不同平台（如 32-bit 或 64-bit）運行，可以使用 `typedef` 來確保型別一致：
```c
typedef unsigned int uint;
```
這樣即使 `unsigned int` 在不同平台上可能不同，使用 `uint` 仍可確保一致性。

---

#### **(4) `typedef` 不能取代 `#define`**
雖然 `typedef` 可用來定義型別別名，但它**不能用來定義常數**，例如：
```c
typedef 3.14159 PI;  // ❌ 錯誤，`typedef` 不能用來定義數值
```
如果要定義數值常數，應使用 `#define`。

---

### **2. `#define`（巨集替換）**  

#### **(1) `#define` 的基本概念**  
`#define` 是 C 的**預處理指令**，用於**定義常數或替換程式碼片段**，編譯時會用指定內容取代該名稱。

---

#### **(2) `#define` 的語法**
```c
#define 名稱 替換內容
```
例如：
```c
#define PI 3.14159
```
這樣在程式中所有 `PI` 都會被編譯器替換為 `3.14159`：
```c
double area = PI * 10 * 10;  // 等價於 double area = 3.14159 * 10 * 10;
```

---

#### **(3) `#define` 的應用**
##### **(a) 定義常數**
`#define` 常用於定義數值常數：
```c
#define MAX_SIZE 100
int array[MAX_SIZE]; // 等價於 int array[100];
```
但 C99 之後，建議使用 `const` 來定義常數：
```c
const double PI = 3.14159;
```

##### **(b) 定義函式樣式的巨集**
`#define` 可以用來創建簡單的函式巨集：
```c
#define SQUARE(x) ((x) * (x))
```
使用時：
```c
int result = SQUARE(5); // 25
```
**注意：使用括號避免優先順序問題**：
```c
#define BAD_SQUARE(x) x * x
int r = BAD_SQUARE(4 + 1); // 會變成 4 + 1 * 4 + 1 = 4 + 4 + 1 = 9（錯誤）
```
因此，應該寫成：
```c
#define SAFE_SQUARE(x) ((x) * (x))
int r = SAFE_SQUARE(4 + 1); // 正確結果 25
```

##### **(c) 條件編譯**
`#define` 可與 `#ifdef`、`#ifndef` 搭配使用，讓程式碼根據條件選擇性編譯：
```c
#define DEBUG  // 定義 DEBUG，表示開啟除錯模式

#ifdef DEBUG
    #define LOG(x) printf("DEBUG: %s\n", x)
#else
    #define LOG(x)
#endif
```
如果 `DEBUG` 被定義，`LOG(x)` 會輸出訊息；如果沒有定義 `DEBUG`，則 `LOG(x)` 什麼都不做。

---

#### **(4) `#define` 與 `typedef` 的區別**
| **比較項目** | `#define` | `typedef` |
|-------------|----------|-----------|
| **主要功能** | 文字替換 | 型別別名 |
| **適用對象** | 常數、運算式、程式碼片段 | 型別 |
| **是否有型別檢查** | ❌ 沒有 | ✅ 有型別檢查 |
| **是否能定義常數** | ✅ 可以 | ❌ 不能 |
| **是否能簡化 `struct`** | ❌ 不能 | ✅ 可以 |
| **是否影響編譯時行為** | ✅ 是預處理指令，影響編譯前的程式碼 | ❌ 只是型別別名，不影響程式編譯 |

---

### **3. `typedef` 與 `#define` 的結合**
可以結合 `#define` 和 `typedef`，例如：
```c
#define uint unsigned int
typedef unsigned int uint;
```
兩者的效果類似，但 `typedef` 更有型別檢查，而 `#define` 只是純文字替換。

---

### **4. `typedef` 與 `#define` 的應用場景**
✅ **使用 `typedef` 的情境**
- 需要**型別別名**，如 `ulong`
- **簡化結構體 (`struct`) 宣告**
- **提高可移植性**，如 `typedef unsigned int uint;`

✅ **使用 `#define` 的情境**
- **定義數值常數**，如 `#define PI 3.14159`
- **創建簡單的函式巨集**，如 `#define SQUARE(x) ((x) * (x))`
- **條件編譯**，如 `#ifdef DEBUG`

---

在 C 語言開發中，善用 `typedef` 和 `#define` 可以讓程式碼更清晰、易讀，提高可維護性！ 

## 11. `volatile`、`restrict`、`const`


- **`volatile` 避免編譯器最佳化變數讀取，確保每次讀取都來自記憶體。**
- **`restrict` 告訴編譯器該指標是唯一存取該記憶體的方式，允許更好的最佳化。**
- **`const` 限制變數不可修改，提高程式安全性與可讀性。**
- **它們可以一起使用，例如：**
  ```c
  void process(volatile const int *restrict ptr);
  ```
  這表示 `ptr` 指向的內容是 `const`（不可改變），且 `ptr` 是唯一訪問記憶體的方式，並且該變數的值可能會變動（`volatile`）。 


### **1. `volatile`（易變變數）**  

#### **(1) `volatile` 的基本概念**  
`volatile` 告訴編譯器，該變數的值**可能會在程式以外的地方被修改**，因此**不能進行最佳化**。這對於**硬體寄存器、記憶體共享、或多執行緒程式**至關重要。

---

#### **(2) `volatile` 的語法**
```c
volatile 資料型別 變數名稱;
```
例如：
```c
volatile int flag;
```
這表示 `flag` 的值可能會被**外部程式或硬體**改變，編譯器每次存取 `flag` 時，**都必須重新讀取記憶體**，不能假設它的值不變。

---

#### **(3) `volatile` 的應用**
##### **(a) 硬體控制暫存器**
在嵌入式系統中，某些變數對應到硬體暫存器，其值可能會被硬體改變：
```c
volatile int *status = (int *)0x4000;  // 指向某個硬體暫存器
while (*status == 0);  // 需要不斷檢查狀態
```
如果沒有 `volatile`，編譯器可能會最佳化 `while (*status == 0);` 成 `while (true);`，因為它假設 `*status` 不會變。

##### **(b) 訊號處理（Signal Handling）**
當程式需要處理外部訊號時，`volatile` 可確保變數的值**不會被最佳化**：
```c
volatile int flag = 0;

void signalHandler() {
    flag = 1;  // 在訊號發生時改變 flag
}
```

##### **(c) 多執行緒共享變數**
在多執行緒環境下，變數可能被不同執行緒修改，因此需要 `volatile`：
```c
volatile int sharedVar;
```
這確保每次讀取 `sharedVar` 時，都是從記憶體中讀取，而不是從 CPU 暫存器或快取中讀取。

---

### **2. `restrict`（指標限定符）**  

#### **(1) `restrict` 的基本概念**  
`restrict` 是 C99 引入的**指標限定符**，它告訴編譯器：**該指標是唯一訪問目標記憶體的方式**。這讓編譯器可以進行更積極的最佳化。

---

#### **(2) `restrict` 的語法**
```c
void process(int *restrict p) { *p = 5; }
```
這表示 `p` 指向的記憶體只能透過 `p` 來存取，不能透過其他指標存取。

---

#### **(3) `restrict` 的應用**
##### **(a) 陣列運算最佳化**
```c
void add(int *restrict a, int *restrict b, int *restrict c, int n) {
    for (int i = 0; i < n; i++) {
        c[i] = a[i] + b[i];
    }
}
```
這樣編譯器可以假設 `a`、`b`、`c` 指向的記憶體**不會重疊**，可以進行更有效率的最佳化，如向量化運算。

##### **(b) 讓編譯器更有效率**
如果 `restrict` 被使用，編譯器不需要擔心記憶體別名 (aliasing) 的問題，可以生成更快的程式碼。例如：
```c
void multiply(int *restrict x, int *restrict y) {
    *x = *x * *y;
}
```
如果 `x` 和 `y` 指向相同記憶體，但我們仍然使用 `restrict`，那麼行為將變成**未定義行為 (Undefined Behavior)**。

---

### **3. `const`（唯讀變數）**  

#### **(1) `const` 的基本概念**  
`const` 限制變數的值**不能被修改**，確保變數是唯讀的，提升程式的**安全性與可讀性**。

---

#### **(2) `const` 的語法**
```c
const 資料型別 變數名稱;
```
例如：
```c
const int MAX = 100;
```
`MAX` 的值無法被修改：
```c
MAX = 200;  // ❌ 錯誤，因為 MAX 是 const
```

---

#### **(3) `const` 的應用**
##### **(a) 保護變數**
```c
const double PI = 3.14159;
```
這確保 `PI` 不會被意外修改。

##### **(b) 保護指標內容**
```c
void display(const char *message) {
    // message 指向的內容不能修改
}
```
這樣 `message` 內部的字串不能被函式改變。

##### **(c) 陣列參數防止修改**
```c
void printArray(const int *arr, int size) {
    // arr 指向的內容不能改變
}
```

##### **(d) `const` 與指標**
```c
const int *p1;  // p1 指向的值不可變
int *const p2;  // p2 本身不可變，但內容可變
const int *const p3;  // p3 和它指向的值都不可變
```

---

### **4. `volatile`、`restrict`、`const` 的比較**
| **關鍵字**   | **主要用途** |
|-------------|-------------|
| `volatile`  | 告訴編譯器變數的值可能隨時變動，不能進行最佳化。適用於硬體寄存器、多執行緒變數、訊號處理等。 |
| `restrict`  | 告訴編譯器該指標是**唯一訪問**某塊記憶體的方式，允許更積極的最佳化。適用於高效能數值運算。 |
| `const`     | 限制變數的內容不可修改，提高程式安全性。適用於常數定義、函式參數、指標防止修改等。 |

---
 

這三個關鍵字在 C 語言中至關重要，正確使用可以提升程式的**正確性、可讀性、與執行效率**！ 

## 12. 前置處理器（Preprocessor）


### **1. 前置處理器的概述**  

- **`#include`**：用來包含外部檔案，可以是自定義的標頭檔或系統標頭檔。
- **`#define`**：用來定義常數或巨集，進行文字替換。
- **`#ifdef`、`#ifndef`、`#endif`**：條件編譯，用來控制程式碼是否編譯，根據是否已定義某個宏來決定。
- **`#undef`**：取消某個宏的定義，使其不再有效。
- **前置處理器是編譯過程的第一步**，在編譯之前處理程式碼，能夠進行條件編譯、常數替換、包含檔案等操作，從而提升程式的靈活性、可移植性與可維護性。

#### **(1) 前置處理器的基本概念**  
C 語言的前置處理器（Preprocessor）在程式編譯之前**進行源碼的處理**，它並不是編譯器的一部分，而是編譯過程的第一步。前置處理器會處理**指令**（以 `#` 開頭的指令），例如：包含檔案、條件編譯、宏定義等。

---

### **2. 主要的前置處理器指令**  
常見的前置處理器指令包括：

- **`#include`**：包含外部檔案
- **`#define`**：定義宏（常數或巨集）
- **`#ifdef`、`#ifndef`、`#endif`**：條件編譯
- **`#if`、`#else`、`#elif`**：條件編譯（更複雜的條件）
- **`#undef`**：取消宏定義
- **`#line`**：修改行號（較少使用）

---

### **3. `#include` - 包含檔案**  

#### **(1) `#include` 的基本概念**  
`#include` 指令用來將外部檔案的內容**插入到當前檔案**中，這樣可以將多個檔案整合在一起進行編譯。這對於模組化程式碼，讓不同的檔案共享功能非常有用。

---

#### **(2) `#include` 的語法**
```c
#include "檔案名稱"
```
或
```c
#include <檔案名稱>
```

- **`#include "檔案名稱"`**：通常用於包含**自定義的檔案**，檔案會在當前目錄中搜尋。
- **`#include <檔案名稱>`**：通常用於包含**標準庫**或**系統頭檔**，編譯器會在系統目錄中搜尋該檔案。

例如：
```c
#include "myheader.h"  // 包含當前目錄中的自定義標頭檔
#include <stdio.h>      // 包含標準輸入輸出標頭檔
```

---

### **4. `#ifdef`、`#ifndef`、`#endif` - 條件編譯**  

#### **(1) `#ifdef` 的基本概念**  
條件編譯指令讓你根據條件來決定是否包含某段程式碼。最常見的條件編譯指令是 `#ifdef` 和 `#ifndef`。

- **`#ifdef`**（如果已定義）：當某個宏被定義時，編譯器將編譯後面的程式碼。
- **`#ifndef`**（如果未定義）：當某個宏未被定義時，編譯器將編譯後面的程式碼。

---

#### **(2) `#ifdef` 和 `#ifndef` 的語法**
```c
#ifdef 宏名稱
    // 如果宏已定義，編譯這段程式碼
#endif
```
或
```c
#ifndef 宏名稱
    // 如果宏未定義，編譯這段程式碼
#endif
```

---

#### **(3) 使用範例**
```c
#define DEBUG

#ifdef DEBUG
    printf("Debug Mode\n");
#endif
```
上面的程式碼中，`#define DEBUG` 定義了宏 `DEBUG`，因此 `#ifdef DEBUG` 會成立，`printf("Debug Mode\n");` 這行程式碼將會被編譯。

如果你不想讓 `Debug Mode` 被編譯，可以註解掉 `#define DEBUG`，或使用 `#ifndef DEBUG`，這樣當 `DEBUG` 沒有被定義時，程式碼會被編譯。

---

#### **(4) `#elif` 和 `#else` 的語法**
有時候會有多個條件需要判斷，可以使用 `#elif` 和 `#else`：
```c
#define DEBUG

#if defined(DEBUG)
    printf("Debug Mode\n");
#elif defined(RELEASE)
    printf("Release Mode\n");
#else
    printf("Unknown Mode\n");
#endif
```

---

### **5. `#define` - 定義宏**  

#### **(1) `#define` 的基本概念**  
`#define` 用來定義常數或**巨集**，它會在編譯之前進行文字替換。巨集常常用來定義常數、簡單的函式樣式等。

---

#### **(2) `#define` 的語法**
```c
#define 宏名稱 替換內容
```
例如：
```c
#define PI 3.14159
```
這樣，所有的 `PI` 都會在編譯時被替換成 `3.14159`。

---

#### **(3) `#define` 的應用**
##### **(a) 定義常數**
```c
#define MAX_SIZE 100
int arr[MAX_SIZE];  // 等同於 int arr[100];
```

##### **(b) 定義簡單的巨集函式**
```c
#define SQUARE(x) ((x) * (x))
int result = SQUARE(5);  // 等同於 int result = (5) * (5);
```

---

### **6. `#undef` - 取消宏定義**  

#### **(1) `#undef` 的基本概念**  
`#undef` 用來**取消某個宏的定義**，這樣該宏就不再有效。

---

#### **(2) `#undef` 的語法**
```c
#undef 宏名稱
```
例如：
```c
#define MAX 100
#undef MAX
```
這樣，`MAX` 就不再是 100 了，如果再次使用 `MAX`，會產生錯誤。

---

### **7. 前置處理器的常見應用場景**

#### **(1) 調試模式**  
使用 `#ifdef` 和 `#define` 控制調試信息的輸出：
```c
#define DEBUG

#ifdef DEBUG
    printf("Debugging...\n");
#endif
```
這樣可以在開發過程中開啟調試，並在發佈版本時關閉。

#### **(2) 跨平台程式碼**  
條件編譯可以根據平台來選擇性地編譯不同的程式碼：
```c
#ifdef _WIN32
    // Windows 特定程式碼
#elif __linux__
    // Linux 特定程式碼
#endif
```

#### **(3) 版本控制**
有時候會根據不同的版本進行條件編譯：
```c
#define VERSION 2

#if VERSION == 2
    printf("Version 2\n");
#elif VERSION == 1
    printf("Version 1\n");
#endif
```

---

善用前置處理器可以讓你的程式更加靈活，能夠根據不同情況進行調整，提高可移植性！ 

## 13. `inline` 內聯函式
### **1. `inline` 的基本概念**

- **`inline` 函式**讓編譯器將函式呼叫的地方展開為函式內容，避免了函式調用的開銷。
- **內聯函式的優點**包括減少調用開銷、提高執行效率，尤其適用於小型且頻繁呼叫的函式。
- 編譯器可能會根據函式的大小和複雜度，決定是否內聯該函式，因此並不保證每個 `inline` 函式都會被內聯。
- 內聯函式比宏更安全，因為它提供型別檢查並能避免宏的潛在錯誤。


#### **(1) `inline` 函式的概念**  
`inline` 是 C 語言中的一個關鍵字，用於將函式標記為**內聯函式**。當一個函式被聲明為 `inline`，編譯器會嘗試將函式的**呼叫處**直接替換為函式的**函式體內容**，這樣可以避免函式呼叫的開銷（如參數傳遞、返回值處理等）。

內聯函式的目的是提高程式的執行效率，尤其是在函式調用開銷較大的情況下。特別適用於那些短小、頻繁被呼叫的函式。

---

### **2. `inline` 的語法**

```c
inline 資料型別 函式名稱(參數列表) { 函式內容 }
```

例如：
```c
inline int square(int x) { return x * x; }
```
這樣當我們呼叫 `square(5)` 時，編譯器會將 `square(5)` 這個函式呼叫直接替換為 `5 * 5`，從而避免了傳遞參數和返回值的開銷。

---

### **3. `inline` 函式的應用範例**

#### **(1) 定義內聯函式**

```c
inline int add(int a, int b) { return a + b; }
```
這個函式用來計算兩個整數的和。每當你調用 `add(x, y)`，編譯器會將其展開為 `x + y`，這樣就避免了傳遞參數和返回值所需的開銷。

#### **(2) 內聯函式的使用**
```c
#include <stdio.h>

inline int square(int x) {
    return x * x;
}

int main() {
    int num = 5;
    printf("The square of %d is %d\n", num, square(num));  // 這裡會被展開為 square(num) -> num * num
    return 0;
}
```

#### **(3) 適用於簡單函式**

內聯函式特別適用於那些短小且簡單的函式，例如數學運算或單一返回語句的函式：
```c
inline int multiply(int a, int b) {
    return a * b;
}
```

---

### **4. `inline` 的好處與限制**

#### **(1) 優點**
- **減少函式調用的開銷**：內聯函式可以避免函式調用帶來的額外開銷，如參數壓栈、跳轉指令、函式返回等。
- **提高效率**：特別是對於那些小型且頻繁呼叫的函式（例如數學計算函式），內聯可以顯著提升執行效率。

#### **(2) 限制與注意事項**
- **內聯函式不適用於大型函式**：如果函式過於複雜或包含大量程式碼，將其作為內聯函式可能會使得最終的程式碼體積增大，反而減慢程式執行。
- **無法預測的效果**：即使你使用 `inline`，編譯器可能會選擇不將函式內聯（例如如果函式太大、過於複雜，或如果優化策略禁止內聯）。這由編譯器決定，並不保證每次都會內聯。
- **可能增加程式碼大小**：由於每個函式呼叫都會被替換為函式的實際內容，對於大量的函式呼叫，可能會導致程式碼重複，增加最終程式的大小。

#### **(3) 編譯器的決定**
即使函式是 `inline`，編譯器並不一定會內聯它。編譯器會根據一些因素，如函式的大小、複雜度、程式設計等，來決定是否內聯。通常，編譯器會嘗試內聯短小的函式，但對於較大或遞迴的函式，可能會選擇不內聯。

---

### **5. 內聯函式與宏的區別**

- **內聯函式**：提供類似於常規函式的型別檢查、參數傳遞和作用域處理。內聯函式會在編譯過程中進行展開，並且允許編譯器進行錯誤檢查。
  
- **宏（Macro）**：宏是一種文字替換工具，它不會執行型別檢查，也不會考慮參數的作用域。宏在預處理階段被展開。

例如：
```c
#define SQUARE(x) ((x) * (x))
```
這是宏的一個例子，會在編譯前進行文字替換，而內聯函式則有型別檢查，並且在編譯時可執行。

#### **內聯函式的優勢**
- 比宏更安全，因為它提供型別檢查。
- 支援函式作用域，減少錯誤風險。

---

### **6. 內聯函式的使用場景**

### **(1) 數學運算**
像計算平方、立方、加法等簡單的數學運算函式，都是內聯函式的理想候選者，因為它們簡單且經常被調用。
```c
inline int square(int x) {
    return x * x;
}
```

#### **(2) 計算小範圍的函式**
像這樣的簡單函式，也可以選擇使用 `inline`：
```c
inline int add(int a, int b) {
    return a + b;
}
```

#### **(3) 在高效能需求的情境中**
當對效能要求較高且有大量函式調用的情況下，內聯函式可以有效減少函式調用的開銷，從而提高執行效能。

---
**內聯函式是一個強大的工具**，可以在保證函式邏輯清晰的情況下，提升程式執行效能，尤其是在運算密集型應用中！ 

## 14. 記憶體對齊與位元欄位（Memory Alignment & Bit Fields）
- **記憶體對齊**：記憶體對齊有助於提高存取效能，將資料對齊至適當的邊界位置可以減少 CPU 存取記憶體時的延遲。
- **位元欄位**：位元欄位允許在結構中指定資料成員的位數，這樣可以節省記憶體，並用於儲存小範圍的資料（如旗標、狀態碼等）。
- **使用場景**：
  - **記憶體對齊**：用於提升存取效能，尤其在處理較大的資料類型時。
  - **位元欄位**：用於儲存小範圍的數值或旗標，節省記憶體空間。

---

### **1. 記憶體對齊（Memory Alignment）**

#### **(1) 記憶體對齊的概念**
記憶體對齊指的是資料在記憶體中的存儲方式，通常會將資料對齊在其大小的整數倍位置上。這樣的對齊方式有助於提高存取效率，避免 CPU 存取記憶體時的額外延遲。尤其在處理大數據類型（如 `int`、`double`）時，對齊有助於提高運算效能。

例如，在大多數的系統中，`int` 通常要求 4 字節對齊，即它的起始地址必須是 4 的倍數。

---

#### **(2) 記憶體對齊的例子**

考慮以下結構：

```c
struct Example {
    char a;  // 1 字節
    int b;   // 4 字節
};
```

這個結構中，`char` 佔用 1 字節，但 `int` 佔用 4 字節，並且通常需要 4 字節對齊。

#### **(3) 對齊的影響**

在上述例子中，結構 `Example` 的成員會被填充，以符合對齊要求。具體來說，`char` 會佔用 1 字節，但由於 `int` 需要 4 字節對齊，因此在 `char a` 和 `int b` 之間會插入 3 個額外的字節（稱為填充字節）。

在大多數架構中，`Example` 結構的大小會是 8 字節（1 字節給 `char`，3 字節填充，4 字節給 `int`），而不是 5 字節。

---

#### **(4) 記憶體對齊的目標與效果**
- **目標**：提高存取速度，減少存取記憶體時的延遲。
- **效果**：大數據類型（如 `int`、`double`）的資料能夠被更有效率地讀寫，因為大多數硬體要求資料對齊至其大小的整數倍。

---

### **2. 位元欄位（Bit Fields）**

#### **(1) 位元欄位的概念**
位元欄位允許在結構中定義成員變數時，使用少於資料類型的完整位數來儲存資料。這樣可以有效節省記憶體，特別是當資料範圍較小時（如旗標或狀態指示）。在位元欄位中，資料型別後會指定位數。

例如：

```c
struct Flags {
    unsigned int flag1 : 1;  // flag1 占 1 位
    unsigned int flag2 : 2;  // flag2 占 2 位
    unsigned int flag3 : 3;  // flag3 占 3 位
};
```

#### **(2) 位元欄位的語法**
- 在位元欄位中，資料型別後面會跟隨一個冒號和指定的位數。
- 位元欄位可以用來表示布林值、狀態碼等需要少量位數的情況。

---

#### **(3) 位元欄位的使用範例**
以下是一個示範，展示如何使用位元欄位來儲存一組旗標（flags）：

```c
#include <stdio.h>

struct Flags {
    unsigned int flag1 : 1;  // 1 位
    unsigned int flag2 : 2;  // 2 位
    unsigned int flag3 : 3;  // 3 位
};

int main() {
    struct Flags flags;
    
    flags.flag1 = 1; // flag1 設為 1
    flags.flag2 = 3; // flag2 設為 3（最大值 2 位）
    flags.flag3 = 5; // flag3 設為 5（最大值 3 位）

    printf("flag1: %u\n", flags.flag1);
    printf("flag2: %u\n", flags.flag2);
    printf("flag3: %u\n", flags.flag3);

    return 0;
}
```

在這個範例中：
- `flag1` 占用 1 位，`flag2` 占用 2 位，`flag3` 占用 3 位，這樣總共 6 位。
- 當結構 `Flags` 被建立時，它會儲存這些小於完整整數大小的欄位，並且根據系統的記憶體對齊規則填充適當的位元。

---

#### **(4) 位元欄位的限制與注意事項**

- **記憶體對齊**：位元欄位的對齊規則通常與結構中其他成員的對齊規則有關。某些編譯器會自動為位元欄位進行填充，使其對齊到適當的邊界（通常是整數邊界）。
- **大小**：每個位元欄位的大小都受到其型別大小的限制。對於 `unsigned int`，每個位元欄位的最大位數通常不超過 32 位，取決於系統。
- **性能**：位元欄位的使用能夠節省記憶體，但可能會帶來額外的計算開銷，因為需要額外的操作來處理位元級的存取。

---

### **3. 記憶體對齊與位元欄位的應用場景**

#### **(1) 記憶體對齊的應用**
- **數據結構中的對齊**：許多系統和硬體會強制要求數據結構按照某些邊界對齊，例如，`int` 可能需要 4 字節對齊。這樣能提高記憶體存取效能。
- **多平台開發**：當程式需要在多種平台上運行時，理解記憶體對齊規則可以幫助確保程式的跨平台兼容性。

#### **(2) 位元欄位的應用**
- **儲存旗標（Flags）**：位元欄位最常用於儲存小範圍的數值或旗標，這些數值通常需要少量位數來儲存。
- **硬體控制寄存器**：位元欄位可用來映射硬體控制寄存器的位元，這些寄存器的每一位代表不同的控制功能。
- **嵌入式系統**：在嵌入式系統中，位元欄位用於儲存狀態和控制信息，因為嵌入式系統常常有記憶體和儲存空間的限制。

---

理解記憶體對齊與位元欄位的使用，可以幫助程式設計師在需要效能和記憶體控制的情境中做出更加高效的選擇！ 